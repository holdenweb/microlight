# The MIT License (MIT)
# Copyright (c) 2020 Mike Teachman
# https://opensource.org/licenses/MIT

# example for MicroPython rotary encoder
#
# Documentation:
#   https://github.com/MikeTeachman/micropython-rotary

import time
#from rotary_irq_pyb import RotaryIRQ

S = 2  # Scaling factor

current = 0  # Always fade up at power on

#r = RotaryIRQ(pin_num_clk='X1',
              #pin_num_dt='X2',
              #min_val=1,
              #max_val=32,
              #reverse=True,
              #range_mode=RotaryIRQ.RANGE_BOUNDED)

#val_old = r.value()


setting_values = [
    2966, 2966, 2965, 2966, 2967, 2966, 2967, 2967, 2967, 2967, 2967, 2967, 2967, 2967, 2966, 2966, 2966, 2966,
    2966, 2966, 2966, 2965, 2967, 2965, 2966, 2966, 2966, 2964, 2966, 2965, 2992, 2971, 3137, 3679, 4094, 4093,
    4095, 4095, 4095, 4093, 4095, 4029, 3282, 2668, 1985, 1373, 1012, 805, 785, 788, 735, 433, 4, 8, 3, 2, 4,
    3, 4, 4, 92, 485, 865, 1432, 2048, 2666, 3156, 3589, 3859, 4094, 4094, 4095, 4095, 4095, 4095, 4095, 4095,
    4095, 4031, 3709, 3358, 2935, 2489, 1962, 1582, 1119, 711, 433, 190, 2, 2, 4, 4, 4, 4, 3, 4, 3, 4, 2, 3,
    4, 4, 4, 0, 3, 3, 0, 3, 4, 3, 4, 4, 4, 4, 55, 114, 165, 217, 273, 304, 350, 398, 430, 456, 507, 533, 556,
    598, 627, 665, 818, 1751, 2972, 3204, 2955, 1670, 512, 504, 2146, 3234, 3612, 2859, 1243, 286, 3, 4, 4,
    4, 2, 3, 4, 4, 4, 5, 3, 4, 76, 291, 421, 520, 664, 807, 947, 1054, 1149, 1245, 1354, 1458, 1584, 1753, 1930,
    2058, 2212, 2361, 2456, 2517, 2586, 2677, 2775, 2893, 2972, 3025, 3034, 2989, 2868, 2751, 2636, 2490, 2335,
    2189, 2040, 1940, 1846, 1729, 1641, 1560, 1486, 1410, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323, 1323,
    1323
]
setting_values = [0] + [n for n in (1, 2, 40, 40, 20, 40, 40, 40) for i in range(64)]
# setting_values = [x for each_list in setting_values for x in each_list]

val_old = current = target = pct = 0
out_vals = []

for raw_demand in setting_values:
    raw_demand = raw_demand*S
#while True:
    # raw_demand = r.value()*S
    if raw_demand != target:  # retargeting required
        target = raw_demand
        incr = 1 if target > current else -1
        print("Now", current, "incrementing by", incr, "to", target)
    if current != target:  # Move towards target
        current += incr
        pct = current*current/64
        # pwm_ch.pulse_width_percent(pct)
    out_vals.append(pct)
    print(target, current)
#    time.sleep_ms(50)

import numpy as np
import matplotlib.pyplot as plt
plt.plot(out_vals)
plt.plot(setting_values)
plt.plot(np.sqrt(out_vals))
plt.show()
